<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <title>EnvSensor BLE Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

    <script>
      var _oDevice;
      var _oCharaWrite;
      var _oCharaBatt;
      var dataLog = []; // Parsed data history (Live)
      var flashDataLog = []; // Downloaded Flash Data
      var _pollingInterval;

      var _chart; // Chart instance

      // UUID Constants
      const DEVICE_SERVICE_UUID = "4fafc202-1fb5-459e-8fcc-c5c9c331914b";
      const DEVICE_WRITE_CHARACTERISTIC_UUID =
        "beb5483e-36e1-4688-b7f5-ea07361b26a8";
      const DEVICE_READ_CHARACTERISTIC_UUID =
        "beb5483f-36e1-4688-b7f5-ea07361b26a8";

      // Constants for Flash Reading
      const NUM_PAGES = 5;
      const UNIT_DATA_PAGE = 64 * 1024; // 64KB
      const NUM_DATA_SIZE = 28; // Data size per record
      const RECORDS_PER_PAGE = Math.floor(UNIT_DATA_PAGE * 4); 
      
      let isDownloading = false;
      let downloadCursor = { page: 0, index: 0 };
      let downloadTargetPage = -1; // -1: All, 0-4: Specific Page
      let downloadStartTime = 0;

      window.onload = function() {
          initChart();
      };

      function initChart() {
        const ctx = document.getElementById('sensorChart').getContext('2d');
        _chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Env Temp (℃)',
                        borderColor: 'rgb(75, 192, 192)',
                        yAxisID: 'y',
                        data: []
                    },
                    {
                        label: 'Obj Temp (℃)',
                        borderColor: 'rgb(54, 162, 235)',
                        yAxisID: 'y',
                        data: []
                    },
                    {
                        label: 'Acc Avg',
                        borderColor: 'rgb(153, 102, 255)',
                        yAxisID: 'y1',
                        data: []
                    }
                ]
            },
            options: {
                responsive: true,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                stacked: false,
                scales: {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: { display: true, text: 'Temperature (℃)' }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: { drawOnChartArea: false },
                        title: { display: true, text: 'Acceleration' }
                    }
                }
            }
        });
      }

      function updateChart(timeLabel, tmpEnv, tmpObj, accAvg) {
          if (!_chart) return;
          
          _chart.data.labels.push(timeLabel);
          _chart.data.datasets[0].data.push(tmpEnv);
          _chart.data.datasets[1].data.push(tmpObj);
          _chart.data.datasets[2].data.push(accAvg);

          // Get Max Points from Selector
          const maxSec = parseInt(document.getElementById("chart_window").value);
          // Assuming 1Hz sampling
          const maxPoints = maxSec; 

          // Limit history
          while (_chart.data.labels.length > maxPoints) {
              _chart.data.labels.shift();
              _chart.data.datasets[0].data.shift();
              _chart.data.datasets[1].data.shift();
              _chart.data.datasets[2].data.shift();
          }
          
          // Optimization: Update without animation for large datasets if needed, 
          // or throttle updates. For now, simple update.
          _chart.update('none'); // 'none' mode prevents animation for better performance
      }

      async function connect() {
        try {
          const device = await navigator.bluetooth.requestDevice({
            filters: [
              { services: [DEVICE_SERVICE_UUID] },
              { namePrefix: "HAMA" },
            ],
            optionalServices: [0x180f], // Battery Service
          });
          _oDevice = device;
          const server = await device.gatt.connect();
          
          // Connect to Custom Service
          const service = await server.getPrimaryService(DEVICE_SERVICE_UUID);
          const charaRead = await service.getCharacteristic(
            DEVICE_READ_CHARACTERISTIC_UUID
          );
          charaRead.addEventListener(
            "characteristicvaluechanged",
            onRecvSensorData
          );
          await charaRead.startNotifications();
          
          _oCharaWrite = await service.getCharacteristic(
            DEVICE_WRITE_CHARACTERISTIC_UUID
          );

          // Connect to Battery Service (Optional)
          try {
            const battService = await server.getPrimaryService(0x180f);
            _oCharaBatt = await battService.getCharacteristic(0x2a19);
            _oCharaBatt.addEventListener(
              "characteristicvaluechanged",
              onRecvBatteryData
            );
            await _oCharaBatt.startNotifications();
            // Read initial value
            const val = await _oCharaBatt.readValue();
            updateBatteryUI(val.getUint8(0));
          } catch (e) {
            console.warn("Battery service not found or accessible", e);
          }

          document.getElementById("status_text").innerText = "状態: 接続完了 (データ取得中)";
          document.getElementById("status_text").classList.add("text-green-600");
          document.getElementById("btn_download").disabled = false;
          
          // Start Polling
          startPolling();
          
        } catch (error) {
          console.error(error);
          alert("接続に失敗しました: " + error);
        }
      }

      function startPolling() {
        if (_pollingInterval) clearInterval(_pollingInterval);
        _pollingInterval = setInterval(async () => {
          if (isDownloading) return; // Stop polling while downloading

          if (_oCharaWrite) {
             try {
               // Command: Get Latest Data [0x02, 0x01]
               const cmd = new Uint8Array([0x02, 0x01]);
               await _oCharaWrite.writeValue(cmd);
             } catch(e) {
               console.error("Polling error", e);
             }
          }
          
          if (_oCharaBatt) {
            try {
               const val = await _oCharaBatt.readValue();
               updateBatteryUI(val.getUint8(0));
            } catch(e) {
               console.warn("Battery Polling Error", e);
            }
          }
        }, 1000); // 1Hz
      }

      function onRecvBatteryData(event) {
        const val = event.target.value.getUint8(0);
        updateBatteryUI(val);
      }

      function updateBatteryUI(level) {
        document.getElementById("val_batt").innerText = level + " %";
      }

      async function startDownload() {
        if (!_oCharaWrite) return;
        if (isDownloading) return;

        const pageSelect = document.getElementById("page_selector").value;
        downloadTargetPage = parseInt(pageSelect); // -1 or 0-4

        isDownloading = true;
        flashDataLog = [];
        
        // Init Cursor
        if (downloadTargetPage === -1) {
             downloadCursor = { page: 0, index: 0 };
        } else {
             downloadCursor = { page: downloadTargetPage, index: 0 };
        }

        document.getElementById("download_progress").style.width = "0%";
        document.getElementById("download_status").innerText = "ダウンロード準備中...";
        document.getElementById("download_area").classList.remove("hidden");
        // Hide Save Button until finished
        document.getElementById("btn_save_flash").classList.add("hidden");
        
        // Request first record
        requestNextRecord();
      }

      async function requestNextRecord() {
        if (!isDownloading) return;

        // Command: Get Stored Data [0x02, 0x00, Page, IndexLow, IndexHigh]
        const cmd = new Uint8Array(5);
        cmd[0] = 0x02;
        cmd[1] = 0x00;
        cmd[2] = downloadCursor.page;
        cmd[3] = downloadCursor.index & 0xFF;
        cmd[4] = (downloadCursor.index >> 8) & 0xFF;

        try {
           await _oCharaWrite.writeValue(cmd);
           // Timeout handling if no response comes back could be added here
        } catch(e) {
           console.error("Download Request Error", e);
           isDownloading = false;
           alert("ダウンロード中にエラーが発生しました");
        }
      }

      function onRecvSensorData(event) {
        const value = event.target.value;
        const dataView = new DataView(value.buffer);
        
        // Check Header
        if (dataView.getUint8(0) !== 0x82) return;
        const type = dataView.getUint8(1);

        // Type 0x01: Live Sensor Data (30 bytes)
        if (type === 0x01 && value.byteLength >= 30) {
           parseLiveData(dataView);
        }
        // Type 0x00: Stored Flash Data (33 bytes)
        else if (type === 0x00 && value.byteLength >= 33) {
           parseStoredData(dataView);
        }
      }

      function parseLiveData(dataView) {
          const timestamp = dataView.getUint32(2, true);
          
          // Acc Data (10 x uint16)
          let accSum = 0;
          for(let i=0; i<10; i++) {
             accSum += dataView.getUint16(6 + i*2, true);
          }
          const accAvg = accSum / 10.0; 

          // Temperature
          const tmpObj = dataView.getInt16(26, true) / 100.0;
          const tmpEnv = dataView.getInt16(28, true) / 100.0;

          const isError = (tmpEnv < -200.0 || tmpObj < -200.0);

          if (!isError) {
             const timeStr = new Date(timestamp * 1000).toLocaleTimeString();
             document.getElementById("val_temp_env").innerText = tmpEnv.toFixed(2) + " ℃";
             document.getElementById("val_temp_obj").innerText = tmpObj.toFixed(2) + " ℃";
             document.getElementById("val_acc").innerText = accAvg.toFixed(2);
             document.getElementById("val_time").innerText = timeStr;

             updateChart(timeStr, tmpEnv, tmpObj, accAvg);

             const record = {
                time: new Date(timestamp * 1000).toISOString(),
                timestamp: timestamp,
                tmpEnv: tmpEnv,
                tmpObj: tmpObj,
                accAvg: accAvg
             };
             dataLog.push(record);
             addLogTable(record);
          }
      }

      function parseStoredData(dataView) {
          if (!isDownloading) return;

          const page = dataView.getUint8(2);
          const index = dataView.getUint16(3, true);
          
          // Check if it matches requested (Simple validity check)
          if (page !== downloadCursor.page || index !== downloadCursor.index) {
             console.warn("Mismatch response");
             // Retry? or Ignore
          }

          // Parse Data payload starts at index 5
          // Payload Structure: [Time(4), AccSum(20), ObjTmp(2), EnvTmp(2)]
          const b5 = dataView.getUint8(5);
          const b6 = dataView.getUint8(6);
          const b7 = dataView.getUint8(7);
          const b8 = dataView.getUint8(8);

          // Check if bytes 5-8 are 0xFF (Empty/Uninitialized)
          if (b5 === 0xFF && b6 === 0xFF && b7 === 0xFF && b8 === 0xFF) {
              console.log("Found empty record (0xFFFFFFFF). Stopping download.");
              finishDownload();
              return;
          }

          const timestamp = dataView.getUint32(5, true);

          let accSum = 0;
          for(let i=0; i<10; i++) {
             accSum += dataView.getUint16(9 + i*2, true);
          }
          const accAvg = accSum / 10.0; 

          const tmpObj = dataView.getInt16(29, true) / 100.0;
          const tmpEnv = dataView.getInt16(31, true) / 100.0;

          const record = {
             page: page,
             index: index,
             time: new Date(timestamp * 1000).toISOString(),
             timestamp: timestamp,
             tmpEnv: tmpEnv,
             tmpObj: tmpObj,
             accAvg: accAvg
          };

          flashDataLog.push(record);
          
          // Update Progress
          const totalRecords = NUM_PAGES * RECORDS_PER_PAGE; 
          const currentCount = flashDataLog.length;
          const percent = Math.min(100, (currentCount / 1000) * 100); // Just visual feedback, we don't know total valid records easily
          document.getElementById("download_status").innerText = `受信中... ${currentCount}件`;
          
          // Next Record
          downloadCursor.index++;
          if (downloadCursor.index >= RECORDS_PER_PAGE) {
             // End of Page
             downloadCursor.index = 0;
             
             if (downloadTargetPage !== -1) {
                 // Single Page Mode -> Finish
                 finishDownload();
                 return;
             } else {
                 // All Pages Mode -> Next Page
                 downloadCursor.page++;
             }
          }

          if (downloadCursor.page >= NUM_PAGES) {
             finishDownload();
          } else {
             // Request next
             // Use setTimeout to allow UI update and prevent flooding if too fast
             setTimeout(requestNextRecord, 5); 
          }
      }

      function finishDownload() {
         isDownloading = false;
         document.getElementById("download_status").innerText = `完了: ${flashDataLog.length}件`;
         document.getElementById("download_progress").style.width = "100%";
         alert(`ダウンロード完了: ${flashDataLog.length}件のデータを取得しました。CSV保存ボタンを押してください。`);
         document.getElementById("btn_save_flash").classList.remove("hidden");
      }

      function addLogTable(record) {
        const tbody = document.getElementById("log_tbody");
        const row = document.createElement("tr");
        row.innerHTML = `
          <td class="border px-2 py-1">${record.time}</td>
          <td class="border px-2 py-1">${record.tmpEnv.toFixed(2)}</td>
          <td class="border px-2 py-1">${record.tmpObj.toFixed(2)}</td>
          <td class="border px-2 py-1">${record.accAvg.toFixed(2)}</td>
        `;
        tbody.prepend(row);
        // Limit rows
        if (tbody.children.length > 100) tbody.lastElementChild.remove();
      }

      async function updateTimestamp() {
        if (!_oCharaWrite) return;
        const now = Math.floor(Date.now() / 1000);
        const buffer = new ArrayBuffer(6);
        const view = new DataView(buffer);
        view.setUint8(0, 0x00); // Command Header?
        view.setUint8(1, 0x03); // Command ID for Set Timestamp? (Derived from previous code)
        view.setUint32(2, now, true); // Little Endian
        await _oCharaWrite.writeValue(buffer);
        console.log("Timestamp updated sent:", now);
      }

      function exportCSV() {
        if (dataLog.length === 0) {
          alert("データがありません");
          return;
        }
        let csv = "Time,Timestamp,EnvTemp,ObjTemp,AccAvg\n";
        dataLog.forEach(row => {
          csv += `${row.time},${row.timestamp},${row.tmpEnv},${row.tmpObj},${row.accAvg}\n`;
        });
        
        saveCSV(csv, "sensor_data.csv");
      }

      function exportFlashCSV() {
        if (flashDataLog.length === 0) {
          alert("ダウンロードされたデータがありません");
          return;
        }
        let csv = "Page,Index,Time,Timestamp,EnvTemp,ObjTemp,AccAvg\n";
        flashDataLog.forEach(row => {
          csv += `${row.page},${row.index},${row.time},${row.timestamp},${row.tmpEnv},${row.tmpObj},${row.accAvg}\n`;
        });
        
        saveCSV(csv, "flash_data.csv");
      }

      function saveCSV(content, filename) {
        const blob = new Blob([content], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }
    </script>
  </head>

  <body class="bg-gray-100 text-gray-800 font-sans">
    <div class="container mx-auto p-4 max-w-4xl">
      <header class="flex justify-between items-center mb-6">
        <h1 class="text-2xl font-bold text-gray-900">EnvSensor Dashboard</h1>
        <div class="flex items-center gap-4">
          <span id="status_text" class="font-semibold text-gray-500">状態: 未接続</span>
          <button onclick="connect()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded shadow">
            接続
          </button>
        </div>
      </header>

      <!-- Dashboard Cards -->
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
        <!-- Env Temp -->
        <div class="bg-white p-4 rounded-lg shadow border-l-4 border-green-500">
          <p class="text-sm text-gray-500">環境温度</p>
          <p class="text-2xl font-bold" id="val_temp_env">-- ℃</p>
        </div>
        <!-- Obj Temp -->
        <div class="bg-white p-4 rounded-lg shadow border-l-4 border-teal-500">
          <p class="text-sm text-gray-500">対象温度</p>
          <p class="text-2xl font-bold" id="val_temp_obj">-- ℃</p>
        </div>
        <!-- Acc -->
        <div class="bg-white p-4 rounded-lg shadow border-l-4 border-indigo-500">
          <p class="text-sm text-gray-500">加速度(Avg)</p>
          <p class="text-2xl font-bold" id="val_acc">--</p>
        </div>
        <!-- Battery -->
        <div class="bg-white p-4 rounded-lg shadow border-l-4 border-yellow-500">
          <p class="text-sm text-gray-500">バッテリー</p>
          <p class="text-2xl font-bold" id="val_batt">-- %</p>
        </div>
      </div>
      
      <div class="mb-2 text-right text-sm text-gray-500">
        最終更新: <span id="val_time">--:--:--</span>
      </div>

      <!-- Controls -->
      <div class="bg-white p-4 rounded-lg shadow mb-6 flex flex-wrap gap-4 items-center">
        <button onclick="updateTimestamp()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded">
          現在時刻同期
        </button>
        <button onclick="exportCSV()" class="bg-gray-700 hover:bg-gray-800 text-white px-4 py-2 rounded">
          ライブCSV保存
        </button>
        
        <div class="h-8 border-l border-gray-300 mx-2"></div>
         
        <div class="flex items-center gap-2">
            <select id="page_selector" class="border rounded px-2 py-2 text-gray-700 bg-white shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500">
                <option value="-1">All Pages</option>
                <option value="0">Page 0</option>
                <option value="1">Page 1</option>
                <option value="2">Page 2</option>
                <option value="3">Page 3</option>
                <option value="4">Page 4</option>
            </select>
            <button id="btn_download" onclick="startDownload()" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded disabled:bg-gray-400" disabled>
            内部メモリ取得
            </button>
        </div>

        <div class="flex items-center gap-2 ml-auto">
          <label for="chart_window" class="text-sm font-semibold text-gray-600">グラフ表示期間:</label>
          <select id="chart_window" class="border rounded px-2 py-2 text-gray-700 bg-white shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="60">1分</option>
            <option value="300" selected>5分</option>
            <option value="600">10分</option>
            <option value="1800">30分</option>
            <option value="3600">1時間</option>
            <option value="10800">3時間</option>
            <option value="21600">6時間</option>
            <option value="43200">12時間</option>
          </select>
        </div>
      </div>
      
      <!-- Download Status -->
      <div id="download_area" class="bg-white p-4 rounded-lg shadow mb-6 hidden">
        <div class="flex justify-between items-center mb-2">
            <span class="font-bold text-gray-700">ダウンロード状況:</span>
            <span id="download_status">--</span>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2.5 mb-2">
          <div id="download_progress" class="bg-purple-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
        <button id="btn_save_flash" onclick="exportFlashCSV()" class="text-sm bg-blue-500 text-white px-3 py-1 rounded hidden hover:bg-blue-600">
            CSV保存
        </button>
      </div>

      <!-- Chart -->
      <div class="bg-white rounded-lg shadow p-4 mb-6">
        <canvas id="sensorChart" width="400" height="150"></canvas>
      </div>

      <!-- Log Table -->
      <div class="bg-white rounded-lg shadow overflow-hidden">
        <h3 class="bg-gray-50 px-4 py-2 border-b font-semibold">受信データログ (最新100件)</h3>
        <div class="overflow-x-auto h-64">
          <table class="w-full text-sm text-left">
            <thead class="bg-gray-100 text-gray-600 sticky top-0">
              <tr>
                <th class="px-2 py-2">Time</th>
                <th class="px-2 py-2">Env Temp</th>
                <th class="px-2 py-2">Obj Temp</th>
                <th class="px-2 py-2">Acc Avg</th>
              </tr>
            </thead>
            <tbody id="log_tbody">
              <!-- Logs go here -->
            </tbody>
          </table>
        </div>
      </div>

    </div>
  </body>
</html>
